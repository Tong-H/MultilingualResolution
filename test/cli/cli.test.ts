import { describe, expect, test } from "@jest/globals"
import config from "../I18NPLAN.config"
import { get, set, emptyDir } from "../../source/cli"
import path from "node:path"
import { I18NPLAN } from "../../source/type"

const getEntry = async () => (await import("../../source/cli")).default
const rootPath = path.resolve(process.cwd())

const toCollect = async (_config: typeof config, snapshot = true) => {
		const entry = await getEntry()
		const result = await entry(_config)
		snapshot && expect(result).toMatchSnapshot()
	},
	toChange = async (add: boolean) => {
		const testFile = path.resolve(rootPath, "examples/lan/first.lan.json")
		const lanJson = await get(testFile)

		if (add) {
			lanJson["lan1-2"].update = `a random number from 0 to 100 ${Math.floor(Math.random() * 100)}`
			lanJson["lan1-3"] = {
				"lan1-3-1": "this is a test",
				"lan1-3-2": "Force enabled (ASM and ABM)",
				"lan1-3-3": "User choice ( this will clear current setting on the device)",
				"lan1-3-4": "Disable",
				update: `update in ${new Date().toLocaleTimeString()}`,
			}
			delete lanJson["lan2-3"]
		} else {
			delete lanJson["lan1-3"]
			delete lanJson["lan1-2"].update
			lanJson["lan2-3"] = {
				error: {
					format: "password must contain ${formats}",
					confilcts: "the user name ${username} is existed",
				},
			}
		}
		await set(testFile, lanJson)
	},
	getConfig = (item: string): I18NPLAN.Config => {
		const isAutotranslate = /autotranslate/.test(item)
		const isCustomtranslate = /customtranslate/.test(item)

		return {
			...{},
			...config,
			output: config.output + "/" + item,
			translation: {
				...{},
				...(config.translation || {}),
				auto: !!(isAutotranslate || isCustomtranslate),
				...(isCustomtranslate
					? {
							resolve: {
								custom: ({ config, content }) => {
									return new Promise((resolve, reject) => {
										resolve([{ ... content[0], value: "this is generated by a custom translator" }])
									})
								},
							},
					  }
					: {}),
			},
		}
	},
	cleanTestEffects = () => {
		toChange(false)
	}
describe("init", () => {
	test(
		"default",
		async () => {
			const _config = getConfig("default")
			emptyDir(path.resolve(rootPath, _config.output))
			process.argv.push("for=collect")
			await toCollect(_config)
		},
		30 * 1000
	)
	test(
		"customtranslate",
		async () => {
			const _config = getConfig("customtranslate")
			emptyDir(path.resolve(rootPath, _config.output))
			process.argv.push("for=collect")
			await toCollect(_config)
		},
		70 * 1000
	)
	test(
		"autotranslate",
		async () => {
			const _config = getConfig("autotranslate")
			emptyDir(path.resolve(rootPath, _config.output))
			process.argv.push("for=collect")
			await toCollect(_config)
		},
		70 * 1000
	)
})
describe("collect", () => {
	test(
		"default",
		async () => {
			await toChange(true)
			const _config = getConfig("default")
			process.argv.push("for=collect")
			process.argv.push("for=collect")
			await toCollect(_config)
			cleanTestEffects()
		},
		30 * 1000
	)
	test(
		"autotranslate",
		async () => {
			await toChange(true)
			const _config = getConfig("autotranslate")
			process.argv.push("for=collect")
			await toCollect(_config)
			cleanTestEffects()
		},
		30 * 1000
	)
	test(
		"customtranslate",
		async () => {
			await toChange(true)
			const _config = getConfig("customtranslate")
			process.argv.push("for=collect")
			await toCollect(_config)
			cleanTestEffects()
		},
		30 * 1000
	)
})

describe("export", () => {
	test(
		"export",
		async () => {
			const _config = getConfig("autotranslate")
			process.argv.push("for=export")
			await toCollect(_config)
		},
		30 * 1000
	)
})

describe("import", () => {
	test(
		"import",
		async () => {
			const _config = getConfig("autotranslate")
			process.argv.push("for=import")
			await toCollect(_config)
		},
		30 * 1000
	)
})
